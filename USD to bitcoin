# Importing required libraries
import logging
from flask import Flask, request, jsonify
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from wtforms import ValidationError
from werkzeug.security import generate_password_hash, check_password_hash
from flask_sqlalchemy import SQLAlchemy

# Initialize Flask app and configure database
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///balances.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# Initialize rate limiter
limiter = Limiter(app, key_func=get_remote_address)
limiter.limit("100/minute")

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Define Balance model for database
class Balance(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    account_balance = db.Column(db.Float, default=100000)
    wallet_balance = db.Column(db.Float, default=0)

# Store API keys securely hashed
API_KEY = generate_password_hash('secret-key')

def validate_api_key(key):
    return check_password_hash(API_KEY, key)

def validate_input(data):
    if 'amount' not in data:
        raise ValidationError("Missing amount parameter")
    try:
        amount = float(data['amount'])
        if amount < 0:
            raise ValidationError("Invalid amount")
    except ValueError:
        raise ValidationError("Invalid amount")

# Placeholder for input sanitization
def sanitize_input(data):
    # Add your sanitization logic here if needed
    pass

@app.before_request
def limit_remote_addr():
    if request.method != 'GET':
        limiter.check()

@app.before_request
def validate_api_key():
    if request.args.get('api_key') != API_KEY:
        return jsonify({"error": "Invalid API key"}), 401

@app.route("/convert", methods=['POST'])
def convert():
    try:
        # Simulating a merchant request
        merchant_data = {
            'amount': request.form.get('amount'),
            'merchant_percentage': request.form.get('merchant_percentage', 0.05),
        }

        # Validate and sanitize merchant input
        sanitize_input(merchant_data)
        validate_input(merchant_data)

        # Calculate the amount to be converted to Bitcoin
        amount_fiat = float(merchant_data['amount'])
        merchant_percentage = float(merchant_data['merchant_percentage'])

        # Simulate the conversion to Bitcoin
        balance = Balance.query.first()
        balance.account_balance -= amount_fiat * merchant_percentage
        amount_to_wallet = amount_fiat * merchant_percentage * 0.000020
        balance.wallet_balance += amount_to_wallet
        db.session.commit()

        # For illustration purposes, let's assume a successful conversion
        conversion_result = {
            'result': 'success',
            'amount_fiat': amount_fiat,
            'amount_to_convert': amount_fiat * merchant_percentage,
            'amount_to_wallet': amount_to_wallet,
            'conversion_rate': 0.000020,
            'merchant_conversion_percentage': merchant_percentage,
            'bank_account_balance': balance.account_balance,
            'wallet_balance': balance.wallet_balance
        }

        # Return the result to the merchant
        return jsonify(conversion_result), 200

    except (ValidationError, ValueError) as e:
        return jsonify({"error": str(e)}), 400

if __name__ == '__main__':
    # Create database tables
    db.create_all()

    # Check if the Balance table is empty, and initialize with default values if needed
    if not Balance.query.first():
        default_balance = Balance()
        db.session.add(default_balance)
        db.session.commit()

    # Run the application
    app.run(debug=True)
