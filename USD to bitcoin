# Importing required libraries
import logging
import os
from flask import Flask, request, jsonify
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from wtforms import ValidationError
from werkzeug.security import generate_password_hash, check_password_hash
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager, create_access_token, jwt_required
from datetime import timedelta  # Add this import statement

# Initialize Flask app and configure extensions
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URI')  # Use environment variable for database URI
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['JWT_SECRET_KEY'] = os.getenv('JWT_SECRET_KEY')  # Use environment variable for secret key
app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(hours=1)
db = SQLAlchemy(app)
jwt = JWTManager(app)

# Initialize rate limiter
limiter = Limiter(app, key_func=get_remote_address)
limiter.limit("100/minute")

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Define Balance model for the database
class Balance(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    account_balance = db.Column(db.Float, default=100000)
    wallet_balance = db.Column(db.Float, default=0)

# Store API keys securely hashed
API_KEY = generate_password_hash(os.getenv('API_KEY'))  # Use environment variable for API key

def validate_api_key(api_key):
    return check_password_hash(API_KEY, api_key)

def validate_input(data):
    if 'amount' not in data:
        raise ValidationError("Missing amount parameter")
    try:
        amount = float(data['amount'])
        if amount < 0:
            raise ValidationError("Invalid amount")
    except ValueError:
        raise ValidationError("Invalid amount")

# Placeholder for input sanitization
def sanitize_input(data):
    # Add your sanitization logic here if needed
    pass

@app.before_request
def limit_remote_addr():
    if request.method != 'GET':
        limiter.check()

@app.route("/api/v1/convert", methods=['POST'])
@jwt_required()
def convert():
    try:
        # Simulating a merchant request
        merchant_data = {
            'amount': request.form.get('amount'),
            'merchant_percentage': request.form.get('merchant_percentage', 0.05),
        }

        # Validate and sanitize merchant input
        sanitize_input(merchant_data)
        validate_input(merchant_data)

        # Calculate the amount to be converted to Bitcoin
        amount_fiat = float(merchant_data['amount'])
        merchant_percentage = float(merchant_data['merchant_percentage'])

        # Simulate the conversion to Bitcoin
        balance = Balance.query.first()
        balance.account_balance -= amount_fiat * merchant_percentage
        amount_to_wallet = amount_fiat * merchant_percentage * 0.000020
        balance.wallet_balance += amount_to_wallet
        db.session.commit()

        # Create a JWT token for the response (as an example)
        access_token = create_access_token(identity=str(balance.id))

        # For illustration purposes, let's assume a successful conversion
        conversion_result = {
            'result': 'success',
            'amount_fiat': amount_fiat,
            'amount_to_convert': amount_fiat * merchant_percentage,
            'amount_to_wallet': amount_to_wallet,
            'conversion_rate': 0.000020,
            'merchant_conversion_percentage': merchant_percentage,
            'bank_account_balance': balance.account_balance,
            'wallet_balance': balance.wallet_balance,
            'access_token': access_token
        }

        # Return the result to the merchant
        return jsonify(conversion_result), 200

    except ValidationError as e:
        # Log detailed validation error information
        logging.error(f"Validation error: {str(e)}")
        return jsonify({"error": str(e)}), 422
    except ValueError as e:
        # Log detailed value error information
        logging.error(f"Value error: {str(e)}")
        return jsonify({"error": str(e)}), 422
    except Exception as e:
        # Log unexpected error information
        logging.error(f"Unexpected error: {str(e)}")
        return jsonify({"error": "An unexpected error occurred"}), 500

if __name__ == '__main__':
    # Create database tables
    db.create_all()

    # Check if the Balance table is empty, and initialize with default values if needed
    if not Balance.query.first():
        default_balance = Balance()
        db.session.add(default_balance)
        db.session.commit()

    # Run the application
    app.run(debug=True)
